# 1. 实验目的及实验要求
## 功能

实现一个提供网上购书功能的网站后端。网站支持书商在上面开商店，购买者可以通过网站购买。

买家和卖家都可以注册自己的账号。

一个卖家可以开一个或多个网上商店，买家可以为自己的账户充值，在任意商店购买图书。支持【下单->付款->发货->收货】流程。

1. 实现对应接口的功能，其中包括：
* 用户权限接口，如注册、登录、登出、注销
* 买家用户接口，如充值、下单、付款
* 卖家用户接口，如创建店铺、填加书籍信息及描述、增加库存
通过对应的功能测试，所有 test case 都 pass 

2. 为项目添加其它功能 ：(40%）
* 实现后续的流程 - 发货 -> 收货
* 搜索图书：用户可以通过关键字搜索，参数化的搜索方式；
  * 如搜索范围包括，题目，标签，目录，内容；
  * 全站搜索或是当前店铺搜索。
  * 如果显示结果较大，需要分页（使用全文索引优化查找）
* 订单状态，订单查询和取消定单
用户可以查自已的历史订单，用户也可以取消订单。

取消定单可由买家主动地取消定单，或者买家下单后，经过一段时间超时仍未付款，定单也会自动取消。 

## bookstore 目录结构

```plain
bookstore
  |-- be                            后端
        |-- model                     后端逻辑代码
        |-- view                      访问后端接口
        |-- ....
  |-- doc                           JSON API 规范说明
  |-- fe                            前端访问与测试代码
        |-- access
        |-- bench                     效率测试
        |-- data                    
            |-- book.db                 sqlite 数据库(book.db，较少量的测试数据)
            |-- book_lx.db              sqlite 数据库(book_lx.db， 较大量的测试数据，要从网盘下载)
            |-- scraper.py              从豆瓣爬取的图书信息数据的代码
        |-- test                      功能性测试（包含对前 60%功能的测试，不要修改已有的文件，可以提 pull request 或 bug）
        |-- conf.py                   测试参数，修改这个文件以适应自己的需要
        |-- conftest.py               pytest 初始化配置，修改这个文件以适应自己的需要
        |-- ....
  |-- ....
```

## 要求

2～3 人一组，做好分工，完成下述内容：

1. bookstore 文件夹是该项目的 demo，采用 Flask 后端框架与 SQLite 数据库，实现了前 60%功能以及对应的测试用例代码。
 **要求创建本地 MongoDB 数据库，将** `bookstore/fe/data/book.db` **中的内容以合适的形式存入本地数据库，后续所有数据读写都在本地的 MongoDB 数据库中进行****。**

2. 在完成前 60%功能的基础上，继续实现后 40%功能，要有接口、后端逻辑实现、数据库操作、代码测试。对所有接口都要写 test case，通过测试并计算测试覆盖率（尽量提高测试覆盖率）。
3. 尽量使用索引，对程序与数据库执行的性能有考量
4. 尽量使用 git 等版本管理工具
5. 不需要实现界面，只需通过代码测试体现功能与正确性
## 报告内容

1.每位组员的学号、姓名，以及分工

2.文档数据库设计：文档 schema

3.对 60%基础功能和 40%附加功能的接口、后端逻辑、数据库操作、测试用例进行介绍，展示测试结果与测试覆盖率。

4.如果完成，可以展示本次大作业的亮点，比如要求中的“3 4”两点。

注：验收依据为报告，本次大作业所作的工作要完整展示在报告中。

## 验收与考核准测

* 提交 **代码+报告** 压缩包到 **作业提交入口**
* 命名规则：2024_ECNU_PJ1_第几组(.zip)
* 提交截止日期：**2024.04.30 23:59**
考核标准：

1. 没有提交或没有实质的工作，得 D
2. 完成"要求"中的第 1 点，可得 C
3. 完成前 3 点，通过全部测试用例且有较高的测试覆盖率，可得 B
4. 完成前 2 点的基础上，体现出第 3 4 点，可得 A
5. 以上均为参考，最后等级会根据最终的工作质量有所调整

---
# 2. 小组成员组成及分工
|学生姓名|学号|分工| 
|:----|:----|:----| 
|	王雪飞|10225501435|文档数据库设计、用户功能实现、拓展功能实现、测试、报告撰写| 
|	贺云航|10225101419|文档数据库设计、买家功能实现、拓展功能实现、测试、报告撰写| 
|	姜嘉祺|10225501447|文档数据库设计、卖家功能实现、拓展功能实现、测试、报告撰写| 


---
# 3. 文档数据库设计
本团队综合考虑实际业务逻辑，在数据中设计了四种文档模式：用户、订单、书籍、商店，其中买家和卖家均使用用户文档，他们的存储关系如下图所示。

![Schema]("https://raw.githubusercontent.com/Jinbao2333/Projects_CDMS2024/58b346bf1f3fcd293e0faf5a532b18e99799d25d/allsturead/Project_1/bookstore/store_schema.svg")

---
# 4. 基本功能实现
## 4.1 用户

### 4.1.1 两个辅助验证函数

#### 4.1.1.1 check_token

**接受两个参数:**

1. user_id: 要验证 token 的用户名；
2. token: 要验证的 token。
**返回值是一个元组(整数，字符串)**

1.  整数代表操作码，200 表示成功，5XX 表示某种错误；
2.  字符串描述操作的结果。
**函数流程：**

1. 查询数据库中该 user_id 的信息；
2. 如果该用户名不存在，返回错误信息；
3. 从数据库中获取 db_token;
4. 使用__check_token()函数验证输入的 token 跟数据库中存放的 db_token 是否一致；
5. 如果验证失败，返回错误信息；
6. 如果验证成功，返回操作码 200 和 "ok"。
#### 4.1.1.2 check_password

**接受两个参数:**

1. user_id: 要验证密码的用户名；
2. password: 要验证的密码。
**返回值是一个元组(整数，字符串)**

1. 整数代表操作码，200 表示成功，5XX 表示某种错误；
2. 字符串描述操作的结果。
**函数流程：**

1. 查询数据库中该 user_id 的信息；
2. 如果该用户名不存在，返回错误信息；
3. 从数据库中获取 db_password;
4. 验证输入的密码跟数据库中存放的密码是否一致；
5. 如果验证失败，返回错误信息；
6. 如果验证成功，返回操作码 200 和 "ok"。
	 

### 4.1.2 用户注册与注销

**register()接受两个参数：**
1. user_id:注册账户的用户名
2. password:账户的密码

**返回值是一个元组:(整数，字符串)**
1. 整数代表操作码，200 表示注册成功，5XX 代表错误
2. 字符串来描述操作结果

**函数流程：**
1. 首先生成一个唯一的标识 terminal；
2. 生成一个 token;
3. 将用户的信息插入到数据库中，包括 user_id, password, balance, token, terminal。

	

**unregister()接受两个参数：**
1. user_id: 要注销的账户的用户名；
2. password: 该账户的密码。
**返回值也是一个元组：(整数，字符串)**
1. 整数代表操作码，200 表示操作成功，401 表示操作异常；
2. 字符串描述操作的结果。

**函数流程：**
1. 调用 check_password()来检查账户名跟密码是否正确；
2. 如果验证失败，返回错误码和错误信息；
3. 如果验证成功，从数据库中删除该用户名和对应的密码；
4. 检查删除的结果，如果成功删除了一个用户，就返回操作码 200 和 "ok" 表示操作成功；
5. 如果未能成功删除该用户，则返回错误信息；
6. 如果在上述过程中发生任何异常，返回异常操作码和错误信息。
 

### 4.1.3 用户登入和登出

**login() 函数接受三个参数：**
1. user_id: 要登录账户的用户名；
2. password: 该账户的密码；
3. terminal: 终端标识。

**返回值是一个三元组（整数，字符串，字符串）：**
1. 整数代表操作码，200 表示成功；
2. 第一个字符串描述操作的结果；
3. 第二个字符串代表生成的 token。

**函数流程：**
1. 调用 check_password 函数验证用户名和密码是否正确；
2. 生成新的 token；
3. 更新数据库中该账户的信息，包括 token 和 terminal。

异常处理就不再描述。
	 

**logout() 接受两个参数：**
1. user_id: 要登出的用户名；
2. token: 用户的令牌。

**返回值是一个二元组（整数，字符串）**
1. 整数代表操作码；
2. 字符串描述操作结果。

**函数流程：**
1. 调用 check_token() 验证用户提供的 token 是否有效；
2. 若有效，生成一个新的终端表示和 token;
3. 更新数据库中的信息，包括 terminal 和 token;

不再描述异常处理。
	 

### 4.1.4 用户修改密码

**change_password()接受三个参数：**

1. user_id: 要修改密码的账户的用户名；
2. old_password: 账户的旧的密码；
3. new_password: 账户的新的密码。
**返回值是一个元组(整数，字符串)**

1. 整数表示操作码；
2. 字符串描述操作的结果。
**函数流程：**

1. 调用 check_password()验证账户的旧密码是否正确；
2. 生成一个新的终端表示和 token;
3. 更新数据库中用户的信息,将密码改成 new_password,修改 terminal 和 token。
## 4.2 买家

### 4.2.1 充值

**`add_funds()`函数接受三个参数：**

1. user_id: 用户的注册账号用户名。
2. password: 用户的密码。
3. add_value: 要添加的充值金额。
**返回值是一个元组：(整数，字符串)**

1. 整数代表操作码，200 表示操作成功，5XX 代表错误。
2. 字符串传递可能发生的错误。
**函数流程：**

1. 通过查询数据库找到指定的用户信息。
2. 如果找不到该用户，返回错误码和错误信息，表示授权失败。
3. 检查用户提供的密码是否与数据库中存储的密码匹配，如果不匹配，返回错误码和错误信息，表示授权失败。
4. 使用 update_one()方法更新数据库中指定用户的"balance"字段，增加充值金额。
5. 检查更新操作是否成功匹配了一个用户，如果没有匹配成功，返回错误码和错误信息，表示用户不存在。
6. 如果在上述过程中发生任何异常，返回异常操作码和错误信息。
7. 如果没有发生异常，表示操作成功，返回操作码 200 和空字符串。
### 4.2.2 下单

**`new_order()` 函数接受三个参数：**

1. user_id: 用户的注册账号用户名。
2. store_id: 商店的唯一标识符。
3. id_and_count: 一个包含商品 ID 和数量的列表，表示用户要购买的商品及其对应的数量。
**返回值是一个元组：(整数，字符串，字符串)**

1. 整数代表操作码，200 表示操作成功，5XX 代表错误。
2. 第一个字符串描述操作结果。
3. 第二个字符串是订单的唯一标识符，如果操作失败，则为空字符串。
**函数流程：**

1. 检查用户 ID 是否存在，如果用户 ID 不存在，返回错误码和错误信息，并将空字符串作为订单 ID 的一部分返回。
2. 检查商店 ID 是否存在，如果商店 ID 不存在，返回错误码和错误信息，并将空字符串作为订单 ID 的一部分返回。
3. 生成唯一的订单 ID，格式为"用户 ID_商店 ID_UUID"。
4. 初始化总价格为 0。
5. 对于每个商品 ID 和数量的元组，执行以下操作：
    1. 查询数据库，查找商店中指定商品 ID 的信息。
    2. 如果找不到该商品，返回错误码和错误信息，并将空字符串作为订单 ID 的一部分返回。
    3. 查询数据库，查找指定商品 ID 的价格。
    4. 获取商品的库存水平。
    5. 检查库存是否足够以满足购买数量，如果库存不足，返回错误码和错误信息，并将空字符串作为订单 ID 的一部分返回。
    6. 使用 update_one()方法更新商店中指定商品的库存水平，减去购买数量。
    7. 检查更新操作是否成功修改了库存，如果没有修改成功，返回错误码和错误信息，并将空字符串作为订单 ID 的一部分返回。
    8. 将订单详细信息插入到订单详细信息集合中，包括订单 ID、商品 ID、数量和价格。
    9. 计算此商品的价格和购买数量的总价。
6. 获取当前时间作为订单的创建时间。
7. 将订单信息插入到订单集合中，包括订单 ID、商店 ID、用户 ID、创建时间、总价格和状态。
8. 将订单 ID 赋值给变量 order_id。
9. 如果在上述过程中发生任何异常，返回异常操作码、异常信息和空字符串。
10. 如果没有发生异常，表示操作成功，返回操作码 200、"ok"和订单 ID。
### 4.2.3 付款

**`payment()`函数接受三个参数：**

1. user_id: 用户的注册账号用户名。
2. password: 用户的密码。
3. order_id: 订单的唯一标识符。
**返回值是一个元组：(整数，字符串)**

1. 整数代表操作码，200 表示操作成功，5XX 代表错误。
2. 字符串描述操作结果。
**函数流程：**

1. 查询订单集合，查找具有指定订单 ID 和未付款状态的订单。
2. 如果找不到订单，返回错误码和错误信息。
3. 获取订单中的买家 ID、商店 ID 和总价格。
4. 检查买家 ID 是否与用户 ID 匹配，如果不匹配，返回错误码和错误信息。
5. 查询用户集合，查找具有指定买家 ID 的用户。
6. 如果找不到用户，返回错误码和错误信息。
7. 获取用户的余额。
8. 检查用户输入的密码是否与数据库中存储的密码匹配，如果不匹配，返回错误码和错误信息。
9. 查询商店集合，查找具有指定商店 ID 的商店。
10. 如果找不到商店，返回错误码和错误信息。
11. 获取商店的卖家 ID。
12. 检查卖家 ID 是否存在于用户集合中，如果不存在，返回错误码和错误信息。
13. 检查用户余额是否足够支付订单总价格，如果余额不足，返回错误码和错误信息。
14. 使用 update_one()方法更新具有指定买家 ID 和足够余额的用户的余额，减去订单总价格。
15. 检查更新操作是否成功修改了余额，如果没有修改成功，返回错误码和错误信息。
16. 使用 update_one()方法更新具有指定卖家 ID 的用户的余额，增加订单总价格。
17. 检查更新操作是否成功修改了余额，如果没有修改成功，返回错误码和错误信息。
18. 将订单信息插入到订单集合中，包括订单 ID、商店 ID、买家 ID、状态和总价格。
19. 使用 delete_one()方法从订单集合中删除具有指定订单 ID 和未付款状态的订单。
20. 检查删除操作是否成功删除了订单，如果未能成功删除订单，返回错误码和错误信息。
21. 如果在上述过程中发生任何异常，返回异常操作码和错误信息。
22. 如果没有发生异常，表示操作成功，返回操作码 200 和 "ok"。
## 4.3 卖家

### 4.3.1 添加书籍

**add_book() 函数接受五个参数：**

1. user_id: 卖家的用户 ID。
2. store_id: 商店的 ID。
3. book_id: 图书的 ID。
4. book_json_str: 表示图书信息的 JSON 字符串。
5. stock_level: 图书的库存水平。
**返回值是一个二元组（整数，字符串）：**

1. 整数代表操作码，200 表示成功。
2. 字符串描述操作的结果。
**函数流程：**

1. 首先，检查卖家 ID 是否存在，若不存在则返回错误信息。
2. 接着，检查商店 ID 是否存在，若不存在则返回错误信息。
3. 再次，检查图书 ID 是否已存在于商店中，若存在则返回错误信息。
4. 使用数据库操作，更新商店中的图书列表，添加新的图书信息，包括图书 ID 和库存水平。
5. 将图书信息插入到图书集合中，使用参数中提供的 JSON 字符串转换为字典形式。
6. 如果出现异常，返回错误码和异常信息。
7. 若成功执行所有步骤，返回操作码为 200 和描述信息"ok"。
8. 如果出现任何基本异常，返回错误码 528 和异常的字符串表示形式。
### 4.3.2 创建店铺

**create_store() 函数接受两个参数：**

1. user_id: 卖家的用户 ID。
2. store_id: 要创建的商店 ID。
**返回值是一个二元组（整数，字符串）：**

1. 整数代表操作码，200 表示成功。
2. 字符串描述操作的结果。
**函数流程：**

1. 首先，检查卖家 ID 是否存在，若不存在则返回错误信息。
2. 接着，检查商店 ID 是否已存在，若存在则返回错误信息。
3. 使用数据库操作，向商店集合中插入一条新记录，包括商店 ID、卖家 ID 和一个空的图书列表。
4. 如果出现异常，如卖家 ID 不存在或商店已存在，返回错误码和异常的字符串表示形式。
5. 若成功执行所有步骤，返回操作码为 200 和描述信息"ok"。
### 4.3.3 增加库存

**add_stock_level() 函数接受四个参数：**

1. user_id: 卖家的用户 ID。
2. store_id: 商店的 ID。
3. book_id: 图书的 ID。
4. add_stock_level: 要增加的库存水平（整数）。
**返回值是一个二元组（整数，字符串）：**

1. 整数代表操作码，200 表示成功。
2. 字符串描述操作的结果。
**函数流程：**

1. 首先，检查卖家 ID 是否存在，若不存在则返回错误信息。
2. 接着，检查商店 ID 是否存在，若不存在则返回错误信息。
3. 再次，检查图书 ID 是否存在于商店中，若不存在则返回错误信息。
4. 使用数据库操作，更新商店中指定图书的库存水平，使用 $inc 运算符增加指定值。
5. 如果出现异常，如卖家 ID 不存在、商店 ID 不存在、图书 ID 不存在于商店中，返回错误码和异常的字符串表示形式。
6. 若成功执行所有步骤，返回操作码为 200 和描述信息"ok"。
--- 
# 5. 拓展功能实现
## 5.1 发货与收货

### 5.1.1 发货

**`send_books()`函数接受两个参数：**

1. user_id: 执行此操作的账户的用户名；
2. order_id: 要发货订单的 id。
**返回值是一个元组(整数，字符串)：**

1. 整数代表操作码；
2. 字符串描述操作的结果。
**函数流程：**

1. 查询满足以下两个条件的订单：
	订单的 id 与 order_id 相同;

	订单的状态为已支付但未发货、已发货但未收到、已收到。

2. 获取订单所在商店的 id 和订单状态；
3. 检查此操作的用户是否是商店的拥有者；
4. 检查订单状态是否为 2 或 3，如果是，返回重复发货的报错信息；
5. 调用 update_one()，将订单状态标记为 2。
### 5.1.2 收货

**`receive_books()` 函数接受两个参数：**

1. user_id: 卖家的用户 ID（字符串）。
2. order_id: 订单的 ID（字符串）。 返回值是一个二元组（整数，字符串）：
3. 整数代表操作码，200 表示成功。
4. 字符串描述操作的结果。 
**函数流程：**

1. 首先，通过查询订单集合，找到具有以下条件之一的订单：
* 订单 ID 等于给定的 order_id，并且状态为 1（已支付）。
* 订单 ID 等于给定的 order_id，并且状态为 2（正在配送）。
* 订单 ID 等于给定的 order_id，并且状态为 3（已送达）。
2. 如果未找到满足条件的订单，返回错误信息，表示订单 ID 无效。
3. 获取买家 ID（buyer_id）和订单状态（paid_status）。
4. 如果买家 ID 与提供的 user_id 不匹配，返回错误信息，表示授权失败。
5. 如果订单状态为 1（已支付），返回错误信息，表示图书尚未发货。
6. 如果订单状态为 3（已送达），返回错误信息，表示图书已重复收取。
7. 使用数据库操作，将订单的状态设置为 3（已送达）。
8. 如果出现异常，如数据库操作失败，返回错误码和异常的字符串表示形式。
9. 若成功执行所有步骤，返回操作码为 200 和描述信息"ok"。
## 5.2 搜索

**search()函数接受以下参数：**

1. keyword: 搜索的关键词。
2. store_id (可选): 商店的唯一标识符。
3. page (可选): 搜索结果的页码，默认为 1。
4. per_page (可选): 每页显示的搜索结果数量，默认为 10。
**返回值是一个元组：(整数，列表)**

1. 整数代表操作码，200 表示操作成功，5XX 代表错误。
2. 列表包含搜索结果的信息。
**函数流程：**

1. 构建查询字典，使用关键词进行文本搜索。
2. 如果提供了商店 ID，则查询商店集合，获取该商店的所有图书 ID。
3. 将商店的图书 ID 添加到查询字典中，限制搜索结果仅包含这些图书 ID。
4. 执行查询操作，根据查询字典进行文本搜索，并排除"_id"和"picture"字段。
5. 对搜索结果按相关度进行排序。
6. 根据指定的页码和每页结果数量，跳过相应数量的结果并限制返回的结果数量。
7. 如果在上述过程中发生任何异常，返回异常操作码和错误信息。
8. 如果没有发生异常，表示操作成功，返回操作码 200 和搜索结果的列表。
### 5.2.1 搜索指定标题的图书

search_title_in_store() 函数接受四个参数：

1. title: 要搜索的图书标题（字符串）。
2. store_id: 商店的 ID（字符串）。
3. page_num: 页面号码（整数），用于分页查询。
4. page_size: 每页的图书数量（整数），用于分页查询。
返回值是一个三元组（整数，字符串，列表）：

1. 整数代表操作码，200 表示成功。
2. 第一个字符串描述操作的结果。
3. 列表包含搜索结果的图书信息。
函数流程：

1. 首先，根据图书标题在数据库中进行搜索，使用条件 {"title": title}。
2. 执行查询操作，跳过前面的 (page_num - 1) * page_size 条记录，并限制返回结果数量为 page_size。
3. 将查询结果转换为列表形式。
4. 如果 store_id 不为空字符串，则继续执行以下步骤：
    1. 获取商店的信息。
    2. 遍历查询结果列表，对每本图书执行以下操作：
    3. + 构建查询条件，检查商店中是否存在指定的图书（使用条件 {"store_id": store_id, "books.book_id": b.get('id')}）。
    4. + 查询商店中的图书 ID，如果存在则将该图书添加到 books_in_store 列表中。
    5. 将结果列表更新为 books_in_store。
5. 如果结果列表为空，表示没有找到符合条件的图书，返回错误码 501、描述信息和空列表。
6. 如果成功执行所有步骤，返回操作码为 200、描述信息"ok"和结果列表。
### 5.2.2 搜索指定标签的图书

search_tag_in_store() 函数接受四个参数：

1. tag: 要搜索的图书标签（字符串）。
2. store_id: 商店的 ID（字符串）。
3. page_num: 页面号码（整数），用于分页查询。
4. page_size: 每页的图书数量（整数），用于分页查询。
返回值是一个三元组（整数，字符串，列表）：

1. 整数代表操作码，200 表示成功。
2. 第一个字符串描述操作的结果。
3. 列表包含搜索结果的图书信息。
函数流程：

1. 首先，根据图书标签在数据库中进行搜索，使用条件 {"tags": {"$regex": tag}}。
2. 执行查询操作，跳过前面的 (page_num - 1) * page_size 条记录，并限制返回结果数量为 page_size。
3. 将查询结果转换为列表形式。
4. 如果 store_id 不为空字符串，则继续执行以下步骤：
    1. 获取商店的信息。
    2. 遍历查询结果列表，对每本图书执行以下操作：
    3. + 构建查询条件，检查商店中是否存在指定的图书（使用条件 {"store_id": store_id, "books.book_id": b.get('id')}）。
    4. + 查询商店中的图书 ID，如果存在则将该图书添加到 books_in_store 列表中。
    5. 将结果列表更新为 books_in_store。
5. 如果结果列表为空，表示没有找到符合条件的图书，返回错误码 501、描述信息和空列表。
6. 如果成功执行所有步骤，返回操作码为 200、描述信息"ok"和结果列表。
### 5.2.3 搜索指定内容的图书

search_content_in_store() 函数接受四个参数：

1. content: 要搜索的内容（字符串）。
2. store_id: 商店的 ID（字符串）。
3. page_num: 页面号码（整数），用于分页查询。
4. page_size: 每页的图书数量（整数），用于分页查询。
返回值是一个三元组（整数，字符串，列表）：

1. 整数代表操作码，200 表示成功。
2. 第一个字符串描述操作的结果。
3. 列表包含搜索结果的图书信息。
函数流程：

1. 首先，获取图书的集合。
2. 构建查询条件，使用 "$text" 和 "$search" 运算符进行全文搜索，搜索内容为指定的 content。
3. 执行查询操作，跳过前面的 (page_num - 1) * page_size 条记录，并限制返回结果数量为 page_size。
4. 将查询结果转换为列表形式。
5. 如果 store_id 不为空字符串，则继续执行以下步骤：
* 获取商店的集合。
* 遍历查询结果列表，对每本图书执行以下操作：
* + 构建查询条件，检查商店中是否存在指定的图书（使用条件 {"store_id": store_id, "books.book_id": b.get('id')}）。
* + 查询商店中的图书 ID，如果存在则将该图书添加到 books_in_store 列表中。
* 将结果列表更新为 books_in_store。
1. 如果结果列表为空，表示没有找到符合条件的图书，返回错误码 501、描述信息和空列表。
2. 如果成功执行所有步骤，返回操作码为 200、描述信息"ok"和结果列表。
### 5.2.4 搜索指定作者的图书

`search_author_in_store()` 函数接受四个参数：

1. author: 要搜索的作者（字符串）。
2. store_id: 商店的 ID（字符串）。
3. page_num: 页面号码（整数），用于分页查询。
4. page_size: 每页的图书数量（整数），用于分页查询。
返回值是一个三元组（整数，字符串，列表）：

1. 整数代表操作码，200 表示成功。
2. 第一个字符串描述操作的结果。
3. 列表包含搜索结果的图书信息。
函数流程：

1. 首先，获取图书的集合。
2. 构建查询条件，使用 "author" 字段进行匹配搜索，搜索条件为指定的 author。
3. 执行查询操作，跳过前面的 (page_num - 1) * page_size 条记录，并限制返回结果数量为 page_size。
4. 将查询结果转换为列表形式。
5. 如果 store_id 不为空字符串，则继续执行以下步骤：
* 获取商店的集合。
* 遍历查询结果列表，对每本图书执行以下操作：
* + 构建查询条件，检查商店中是否存在指定的图书（使用条件 {"store_id": store_id, "books.book_id": b.get('id')}）。
* + 查询商店中的图书 ID，如果存在则将该图书添加到 books_in_store 列表中。
* 将结果列表更新为 books_in_store。
1. 如果结果列表为空，表示没有找到符合条件的图书，返回错误码 501、描述信息和空列表。
2. 如果成功执行所有步骤，返回操作码为 200、描述信息"ok"和结果列表。
## 5.3 查询订单

`check_hist_order()` 函数接受一个参数：

1. user_id: 卖家的用户 ID（字符串）。
返回值是一个三元组（整数，字符串，列表）：

1. 整数代表操作码，200 表示成功。
2. 第一个字符串描述操作的结果。
3. 列表包含历史订单的信息。
函数流程：

1. 首先，检查卖家 ID 是否存在，若不存在则返回错误信息。
2. 创建一个空列表 ans 用于存储历史订单信息。
3. 查询未付款的订单，检索数据库中用户 ID 为指定卖家 ID 且状态为 0 的订单。
    1. 如果查询结果存在，则遍历每个订单，并将订单的详细信息添加到 tmp_details 列表中。
    2. 将订单的状态、订单 ID、买家 ID、商店 ID、总价和详细信息添加到 ans 列表中。
    3. 如果订单详细信息查询结果为空，则返回错误信息。
4. 查询已付款的订单，检索数据库中用户 ID 为指定卖家 ID 且状态为 1、2 或 3 的订单。
    1. 如果查询结果存在，则遍历每个订单，并将订单的详细信息添加到 tmp_details 列表中。
    2. 将订单的订单 ID、买家 ID、商店 ID、总价、状态和详细信息添加到 ans 列表中。
    3. 如果订单详细信息查询结果为空，则返回错误信息。
5. 查询已取消的订单，检索数据库中用户 ID 为指定卖家 ID 且状态为 4 的订单。
    1. 如果查询结果存在，则遍历每个订单，并将订单的详细信息添加到 tmp_details 列表中。
    2. 将订单的状态、订单 ID、买家 ID、商店 ID、总价和详细信息添加到 ans 列表中。
    3. 如果订单详细信息查询结果为空，则返回错误信息。
6. 如果出现异常，如卖家 ID 不存在，返回错误码和异常的字符串表示形式。
7. 如果 ans 列表为空，表示没有找到符合条件的订单，返回操作码为 200、描述信息"ok"和字符串"No orders found"。
8. 如果成功执行所有步骤，返回操作码为 200、描述信息"ok"和结果列表。
## 5.4 取消订单

### 5.4.1 手动取消订单

`cancel_order()` 接受两个参数：

1. user_id: 卖家的用户 ID（字符串）。
2. order_id: 订单的 ID（字符串）。
返回值是一个二元组（整数，字符串）：

1. 整数代表操作码，200 表示成功。
2. 字符串描述操作的结果。
函数流程：

1. 首先，使用数据库查询操作，检索状态为未付款 (0) 的订单信息。
* 如果存在符合条件的订单，继续进行后续操作。
* 获取订单的买家 ID、商店 ID 和价格。
* 检查买家 ID 是否与输入的用户 ID 匹配，若不匹配则返回授权失败的错误信息。
* 删除订单 ID 和状态为 0 的订单。
1. 如果未找到未付款订单，则使用数据库查询操作，检索状态为已付款 (1)、已发货 (2) 或已完成 (3) 的订单信息。
* 如果存在符合条件的订单，继续进行后续操作。
* 获取订单的买家 ID、商店 ID 和价格。
* 使用数据库查询操作，检索与商店 ID 相关的商店信息。
* 检查商店信息是否存在，若不存在则返回商店 ID 不存在的错误信息。
* 获取商家 ID。
* 使用数据库更新操作，减少卖家的余额（balance）以支付订单的价格。
* 检查卖家 ID 是否存在，若不存在则返回卖家 ID 不存在的错误信息。
* 使用数据库更新操作，增加买家的余额（balance）以退款订单的价格。
* 检查买家 ID 是否存在，若不存在则返回买家 ID 不存在的错误信息。
* 删除订单 ID 和状态为 1、2 或 3 的订单。
1. 如果未找到符合条件的订单，返回订单 ID 无效的错误信息。
2. 使用数据库查询操作，检索与订单 ID 相关的订单详细信息。
* 对于每本书籍的订单详细信息：
* + 获取书籍 ID 和数量。
* + 使用数据库更新操作，将商店中指定书籍的库存水平增加对应数量。
* + 如果更新操作没有修改任何记录（modified_count 为 0)，返回库存水平过低的错误信息，并附带订单 ID。
1. 使用数据库插入操作，插入一个新的订单记录，包含订单 ID、用户 ID、商店 ID、价格和状态为 4（已取消）。
2. 如果出现异常，如数据库操作失败，返回错误码和异常的字符串表示形式。
3. 如果成功执行所有步骤，返回操作码为 200 和描述信息"ok"。
### 5.4.2 自动取消订单

`auto_cancel_order()` 函数是一个不接受任何参数的函数。

返回值是一个二元组（整数，字符串）：

1. 整数代表操作码，200 表示成功。
2. 字符串描述操作的结果。
函数流程：

1. 首先，定义等待时间（wait_time）为 20 秒。
2. 计算出一个时间间隔（interval），用于筛选出应取消的订单。时间间隔为当前时间减去等待时间，使用 UTC 时间。
3. 使用数据库查询操作，检索出满足以下条件的订单：创建时间早于等待时间间隔且状态为 0（未付款）。
* 如果存在符合条件的订单，进入循环遍历每个订单。
* 获取订单的订单 ID、用户 ID、商店 ID 和价格。
* 使用数据库删除操作，删除订单 ID 和状态为 0 的订单。
* 使用数据库查询操作，检索与订单 ID 相关的订单详细信息。
* 对于每本书籍的订单详细信息：
* + 获取书籍 ID 和数量。
* + 使用数据库更新操作，将商店中指定书籍的库存水平增加对应数量。
* + 如果更新操作没有修改任何记录（modified_count 为 0)，返回错误信息表示库存水平过低，并附带订单 ID。
* 使用数据库插入操作，插入一个新的订单记录，包含订单 ID、用户 ID、商店 ID、价格和状态为 4（已取消）。
1. 如果出现异常，如数据库操作失败，返回错误码和异常的字符串表示形式。
2. 如果成功执行所有步骤，返回操作码为 200 和描述信息"ok"。
## 5.5 索引优化

我们使用索引进行了性能优化，具体地，我们进行了如下优化：

1. 在store文档集的store_id上设置唯一的升序索引；
2. 在user文档集的user_id上设置唯一的升序索引。

---
# 6. 接口
### 6.1 已有接口

1. `be/view/auth.py` 中 login, logout, register, unregister, change_password 分别对应登录，登出，注册，注销，修改密码；
2. `be/view/buyer.py` 中 new_order，payment，add_funds 分别对应发起新订单, 支付, 增加余额；
3. `be/view/seller.py` 中 create_store，add_book，add_stock_level 分别对应创建商店, 增加书目, 增加库存。
### 6.2 添加接口

1. `be/view/buyer.py` 中添加了 receive_books, cancel_order, auto_cancel_order, is_order_cancelled, check_hist_order, search ,分别对应确认收书，取消订单，自动取消订单，订单是否取消，查询订单历史，简单的查找；
2. `be/view/seller.py` 中添加了 send_books, 对应发货功能；
3. `be/view/search.py` 中添加了 search_title, search_tag, search_content, search_author, search_title_in_store,  search_tag_in_store, search_content_in_store, search_author_in_store 分别对应搜索指定标题的图书，指定标签的图书，指定内容的图书，指定作者的图书,在店铺内搜索指定标题的图书，在店铺内搜索指定标签的图书，在店铺内搜索指定内容的图书，在店铺内搜索指定作者的图书。

---
# 7. 测试
## 7.1 test_add_book.py

在测试之前，会自动执行一些初始化操作：

1. 创建一个唯一的卖家 ID（seller_id）和商店 ID（store_id）；
2. 使用卖家 ID 作为密码注册一个新卖家；
3. 创建一个商店，并将其与卖家关联；
4. 从图书数据库中获取一些图书信息。

**测试用例：**

1. ``test_ok()` `: 测试成功添加图书的情况。对于每本图书，调用 add_book()方法添加到商店中。 断言操作返回码为 200，表示添加成功。
2. `test_error_non_exist_store_id()`: 测试使用不存在的商店 ID 添加图书的情况。对于每本图书，使用不存在的商店 ID 调用 add_book()方法尝试添加到商店中。 断言操作返回码不为 200，表示添加失败。
3. `test_error_exist_book_id()`: 测试使用已存在的图书 ID 添加图书的情况。先添加所有图书到商店中。 对于每本图书，再次使用相同的图书 ID 调用 add_book()方法尝试添加到商店中。 断言操作返回码不为 200，表示添加失败。
4. `test_error_non_exist_user_id()`: 测试使用不存在的用户 ID 添加图书的情况。对于每本图书，将卖家 ID 修改为不存在的用户 ID，并调用 add_book()方法尝试添加到商店中。 断言操作返回码不为 200，表示添加失败。
## 7.2 test_add_funds.py

 在测试之前，会自动执行一些初始化操作：

1. 创建一个唯一的用户 ID（user_id）。
2. 使用用户 ID 作为密码注册一个新买家。

**测试用例：**

1. ``test_ok()` `: 测试成功添加资金的情况。 调用 `add_funds()`方法添加资金。 断言操作返回码为 200，表示添加成功。 再次调用 `add_funds()`方法添加负数金额。 断言操作返回码为 200，表示添加成功。
2. `test_error_user_id()`: 测试使用不存在的用户 ID 添加资金的情况。 将用户 ID 修改为不存在的用户 ID。 调用 `add_funds()`方法尝试添加资金。 断言操作返回码不为 200，表示添加失败。
3. ``test_error_password()` `: 测试使用错误的密码添加资金的情况。 将密码修改为错误的密码。 调用 `add_funds()`方法尝试添加资金。 断言操作返回码不为 200，表示添加失败。
## 7.3 test_add_stock_level.py

在测试之前，会自动执行一些初始化操作：

4. 创建一个唯一的用户 ID（user_id）和商店 ID（store_id）。
5. 使用用户 ID 作为密码注册一个新卖家。
6. 创建一个商店，并将其与卖家关联。
7. 从图书数据库中获取一些图书信息。

**测试用例：**

1. `test_error_user_id()`: 测试使用不存在的用户 ID 添加库存的情况。 对于每本图书，将用户 ID 修改为不存在的用户 ID，并调用 add_stock_level()方法尝试添加库存。 断言操作返回码不为 200，表示添加失败。
2. `test_error_store_id()`: 测试使用不存在的商店 ID 添加库存的情况。 对于每本图书，将商店 ID 修改为不存在的商店 ID，并调用 add_stock_level()方法尝试添加库存。 断言操作返回码不为 200，表示添加失败。
3. `test_error_book_id()`: 测试使用不存在的图书 ID 添加库存的情况。 对于每本图书，将图书 ID 修改为不存在的图书 ID，并调用 add_stock_level()方法尝试添加库存。 断言操作返回码不为 200，表示添加失败。
4. ``test_ok()` `: 测试成功添加库存的情况。 对于每本图书，调用 `add_stock_level()`方法添加库存。 断言操作返回码为 200，表示添加成功。
## 7.4 test_cancel_auto.py

 在测试之前，会自动执行一些初始化操作：

1. 创建一个唯一的卖家 ID（seller_id）、商店 ID（store_id）和买家 ID（buyer_id）。
2. 使用买家 ID 作为密码注册一个新买家。
3. 使用 GenBook 类生成图书数据，并关联卖家和商店。
4. 生成购买图书的信息列表和图书 ID 列表。
5. 计算购买图书的总价，并为买家账户添加足够的资金。

**测试用例：**

1. `test_overtime()`: 测试订单超时自动取消的情况。创建一个新订单，等待一段时间后检查订单是否被取消。 断言操作返回码为 200，表示订单已取消。
2. `test_overtime_paid()`: 测试在订单自动取消之前已付款的情况。创建一个新订单，支付订单，等待一段时间后检查订单是否被取消。 断言操作返回码不为 200，表示订单未取消。
3. `test_overtime_canceled_by_buyer()`: 测试在订单自动取消之前被买家取消的情况。创建一个新订单，取消订单，等待一段时间后检查订单是否被取消。 断言操作返回码为 200，表示订单已取消。
## 7.5 test_cancel_order.py

 在测试之前，会自动执行一些初始化操作：

1. 创建一个唯一的卖家 ID（seller_id）、商店 ID（store_id）和买家 ID（buyer_id）。
2. 使用买家 ID 作为密码注册一个新买家。
3. 使用 GenBook 类生成图书数据，并关联卖家和商店。
4. 生成购买图书的信息列表和图书 ID 列表。
5. 计算购买图书的总价，并为买家账户添加足够的资金。

**测试用例：**

1. `test_paid()`: 测试已付款订单的取消情况。 创建一个新订单，支付订单，取消订单。 断言操作返回码为 200，表示订单已取消。
2. `test_unpaid()`: 测试未付款订单的取消情况。 创建一个新订单，取消订单。 断言操作返回码为 200，表示订单已取消。
3. test_invalid_order_id_paid(): 测试使用不存在的订单 ID 取消已付款订单的情况。 创建一个新订单，支付订单，使用不存在的订单 ID 取消订单。 断言操作返回码不为 200，表示取消失败。
4. test_invalid_order_id_unpaid(): 测试使用不存在的订单 ID 取消未付款订单的情况。 创建一个新订单，使用不存在的订单 ID 取消订单。 断言操作返回码不为 200，表示取消失败。
5. test_authorization_error_paid(): 测试使用非法的买家 ID 取消已付款订单的情况。 创建一个新订单，支付订单，使用非法的买家 ID 取消订单。 断言操作返回码不为 200，表示取消失败。
6. test_authorization_error_unpaid(): 测试使用非法的买家 ID 取消未付款订单的情况。 创建一个新订单，使用非法的买家 ID 取消订单。 断言操作返回码不为 200，表示取消失败。
7. test_repeat_cancel_paid(): 测试重复取消已付款订单的情况。 创建一个新订单，支付订单，取消订单，再次取消订单。 断言操作返回码不为 200，表示取消失败。
8. test_repeat_cancel_not_paid(): 测试重复取消未付款订单的情况。 创建一个新订单，取消订单，再次取消订单。 断言操作返回码不为 200，表示取消失败。
## 7.6 test_create_store.py

在测试之前，会自动执行一些初始化操作：

1. 创建一个唯一的用户 ID（user_id）和商店 ID（store_id）。
2. 使用用户 ID 作为密码注册一个新卖家。
**测试用例：**

1. `test_ok()` : 测试成功创建商店的情况。 创建一个新卖家，调用 create_store()方法创建商店。 断言操作返回码为 200，表示创建成功。
2. test_error_exist_store_id(): 测试使用已存在的商店 ID 创建商店的情况。 创建一个新卖家，先创建一个商店。 再次使用相同的商店 ID 调用 create_store()方法尝试创建商店
## 7.7 test_history_order.py

在测试之前，会自动执行一些初始化操作：

1. 创建一个唯一的买家 ID（buyer_id）。
2. 使用买家 ID 作为密码注册一个新买家。
**测试用例：**

1. `test_have_orders()`: 测试存在历史订单的情况。 循环执行以下步骤 10 次： 生成一个唯一的卖家 ID（seller_id）和商店 ID（store_id）。 使用卖家 ID 和商店 ID 生成一些图书信息。 使用卖家 ID 和商店 ID 创建一个新卖家，将图书信息添加到商店中。 使用买家 ID 添加足够的资金。 使用商店 ID 和图书 ID 列表创建一个新订单。 随机选择是否取消订单，如果取消则继续下一次循环。 随机选择是否支付订单，如果支付则进行下一步操作，否则继续下一次循环。 使用卖家 ID 和订单 ID 发货。 随机选择是否取消订单，如果取消则继续下一次循环。 使用买家 ID 和订单 ID 确认收货。 最后，使用买家 ID 调用 check_hist_order()方法检查历史订单。 断言操作返回码为 200，表示操作成功。
2. ``test_non_exist_user_id()` `: 测试使用不存在的用户 ID 检查历史订单的情况。 使用不存在的用户 ID 调用 check_hist_order()方法。 断言操作返回码不为 200，表示操作失败。
3. `test_no_orders()`: 测试没有历史订单的情况。 使用买家 ID 调用 `check_hist_order()`方法。 断言操作返回码为 200，表示操作成功。断言操作返回码不为 200，表示创建失败。
## 7.8 test_login.py

在测试之前，会自动执行一些初始化操作：

1. 创建一个 author 实例，并传入配置文件中的 URL。
2. 注册一个新用户，并获取用户 ID（user_id）和密码（password）。
**测试用例：**

1. ``test_ok()` `: 测试成功登录和登出的情况。 调用 login()方法使用正确的用户 ID 和密码进行登录，获取返回码和令牌（token）。 断言操作返回码为 200，表示登录成功。 使用错误的用户 ID 和令牌调用 logout()方法进行登出，断言操作返回码为 401，表示登出失败。 使用正确的用户 ID 和令牌调用 logout()方法进行登出，断言操作返回码为 200，表示登出成功。
2. `test_error_user_id()`: 测试使用不存在的用户 ID 进行登录的情况。 使用不存在的用户 ID 和正确的密码调用 login()方法进行登录，获取返回码和令牌。 断言操作返回码为 401，表示登录失败。
3. ``test_error_password()` `: 测试使用错误的密码进行登录的情况。 使用正确的用户 ID 和错误的密码调用 `login()`方法进行登录，获取返回码和令牌。 断言操作返回码为 401，表示登录失败。
## 7.9 test_new_order.py

在测试之前，会自动执行一些初始化操作：

1. 创建一个唯一的卖家 ID（seller_id）、商店 ID（store_id）和买家 ID（buyer_id）。
2. 使用卖家 ID 作为密码注册一个新买家。
**测试用例：**

1. `test_non_exist_book_id()`: 测试使用不存在的图书 ID 下单的情况。 生成一个购买图书 ID 列表，其中包含一个不存在的图书 ID。 调用 `new_order()` 方法使用商店 ID 和购买图书 ID 列表进行下单，获取返回码和订单信息。 断言操作返回码不为 200，表示下单失败。
2. `test_low_stock_level()`: 测试购买库存不足的图书的情况。 生成一个购买图书 ID 列表，其中包含库存不足的图书。 调用 `new_order()` 方法使用商店 ID 和购买图书 ID 列表进行下单，获取返回码和订单信息。 断言操作返回码不为 200，表示下单失败。
3. `test_ok()` : 测试成功下单的情况。 生成一个购买图书 ID 列表，其中所有图书的库存充足。 调用 `new_order()` 方法使用商店 ID 和购买图书 ID 列表进行下单，获取返回码和订单信息。 断言操作返回码为 200，表示下单成功。
4. `test_non_exist_user_id()` : 测试使用不存在的买家 ID 进行下单的情况。 生成一个购买图书 ID 列表，其中所有图书的库存充足。 将买家 ID 修改为不存在的用户 ID。 调用 `new_order()` 方法使用商店 ID 和购买图书 ID 列表进行下单，获取返回码和订单信息。 断言操作返回码不为 200，表示下单失败。
5. `test_non_exist_store_id()` : 测试使用不存在的商店 ID 进行下单的情况。 生成一个购买图书 ID 列表，其中所有图书的库存充足。 调用 `new_order()` 方法使用不存在的商店 ID 和购买图书 ID 列表进行下单，获取返回码和订单信息。 断言操作返回码不为 200，表示下单
## 7.10 test_password.py

在测试之前，会自动执行一些初始化操作：

2. 注册一个新用户，使用唯一的用户 ID。
3. 设置用户的旧密码和新密码。
4. 设置用户的终端。
**测试用例：**

1. `test_ok()` : 测试成功修改密码的情况。 使用 password()方法将密码从旧密码修改为新密码。 断言操作返回码为 200，表示密码修改成功。 尝试使用旧密码登录，断言操作返回码不为 200。 尝试使用新密码登录，断言操作返回码为 200。 登出用户，断言操作返回码为 200。
2. `test_error_password()` : 测试提供错误的旧密码的情况。 使用错误的旧密码和新密码调用 password()方法进行密码修改。 断言操作返回码不为 200，表示密码修改失败。 尝试使用新密码登录，断言操作返回码不为 200。
3. `test_error_user_id()` : 测试提供不存在的用户 ID 的情况。 使用不存在的用户 ID、旧密码和新密码调用 password()方法进行密码修改。 断言操作返回码不为 200，表示密码修改失败。 尝试使用新密码登录，断言操作返回码不为 200。
## 7.11 test_payment.py

在测试之前，会自动执行一些初始化操作：

1. 创建一个唯一的卖家 ID（seller_id）、商店 ID（store_id）、买家 ID（buyer_id）和密码（password）。
2. 使用卖家 ID 作为密码注册一个新买家。
3. 生成一些图书信息，并将其与卖家关联。
4. 生成一个订单，并将其与买家关联。
5. 计算订单的总价。
**测试用例：**

1. `test_ok()` : 测试成功支付订单的情况。 调用 `add_funds()`方法为买家账户充值，金额为订单的总价。 断言操作返回码为 200，表示充值成功。 调用 `payment()`方法支付订单。 断言操作返回码为 200，表示支付成功。
2. ``test_authorization_error()``: 测试授权错误的情况。 调用 `add_funds()`方法为买家账户充值，金额为订单的总价。 断言操作返回码为 200，表示充值成功。 将买家的密码修改为错误的密码。 调用 `payment()`方法支付订单。 断言操作返回码不为 200，表示支付失败。
3. `test_not_suff_funds()`: 测试账户余额不足的情况。 调用 `add_funds()`方法为买家账户充值，金额为订单的总价减 1。 断言操作返回码为 200，表示充值成功。 调用 `payment()`方法支付订单。 断言操作返回码不为 200，表示支付失败。
4. `test_repeat_pay()`: 测试重复支付订单的情况。 调用 `add_funds()`方法为买家账户充值，金额为订单的总价。 断言操作返回码为 200，表示充值成功。 调用 `payment()`方法支付订单。 断言操作返回码为 200，表示支付成功。 再次调用 `payment()`方法支付订单。 断言操作返回码不为 200，表示支付失败。
## 7.12 test_receive.py

在测试之前，会自动执行一些初始化操作：

1. 创建一个唯一的卖家 ID（seller_id）、商店 ID（store_id）、买家 ID（buyer_id）和密码（password）。
2. 使用卖家 ID 和商店 ID 创建一个新的卖家和商店。
3. 生成一些图书信息，并生成一个购买图书的订单。
4. 计算订单的总价。
5. 使用买家 ID 作为密码注册一个新买家，并为其账户充值足够的金额以支付订单。
**测试用例：**

1. `test_ok()` : 测试成功接收图书的情况。 调用 `send_books()`方法将图书发送给买家。 断言操作返回码为 200，表示发送成功。 调用 `receive_books()`方法接收图书。 断言操作返回码为 200，表示接收成功。
2. `test_order_error()`: 测试订单错误的情况。 调用 `send_books()`方法将图书发送给买家。 断言操作返回码为 200，表示发送成功。 使用错误的订单 ID 调用 `receive_books()`方法尝试接收图书。 断言操作返回码不为 200，表示接收失败。
3. `test_authorization_error()`: 测试授权错误的情况。 调用 `send_books()`方法将图书发送给买家。 断言操作返回码为 200，表示发送成功。 使用错误的买家 ID 调用 `receive_books()`方法尝试接收图书。 断言操作返回码不为 200，表示接收失败。
4. `test_books_not_send()`: 测试未发送图书的情况。 直接调用 `receive_books()`方法尝试接收图书。 断言操作返回码不为 200，表示接收失败。
5. `test_books_repeat_receive()`: 测试重复接收图书的情况。 调用 `send_books()`方法将图书发送给买家。 断言操作返回码为 200，表示发送成功。 调用 `receive_books()`方法接收图书。 断言操作返回码为 200，表示接收成功。 再次调用 `receive_books()`方法尝试接收图书。 断言操作返回码不为 200，表示接收失败。
## 7.13 test_register.py

在测试之前，会自动执行一些初始化操作：

1. 创建一个唯一的用户 ID（user_id）和密码（password）。
2. 创建一个 Auth 对象。
**测试用例：**

1. test_register_ok(): 测试成功注册用户的情况。 调用 register()方法进行用户注册。 断言操作返回码为 200，表示注册成功。
2. test_unregister_ok(): 测试成功注销用户的情况。 调用 register()方法进行用户注册。 断言操作返回码为 200，表示注册成功。 调用 unregister()方法进行用户注销。 断言操作返回码为 200，表示注销成功。
3. test_unregister_error_authorization(): 测试授权错误的情况。 调用 register()方法进行用户注册。 断言操作返回码为 200，表示注册成功。 使用错误的用户 ID 调用 unregister()方法尝试注销用户。 断言操作返回码不为 200，表示注销失败。 使用错误的密码调用 unregister()方法尝试注销用户。 断言操作返回码不为 200，表示注销失败。
4. test_register_error_exist_user_id(): 测试已存在用户 ID 的情况。 调用 register()方法进行用户注册。 断言操作返回码为 200，表示注册成功。 再次使用相同的用户 ID 调用 register()方法尝试注册用户。 断言操作返回码不为 200，表示注册失败。
## 7.14 test_search.py

在测试之前，会自动执行一些初始化操作：

1. 创建一个唯一的买家 ID（buyer_id）和密码（password）。
2. 使用买家 ID 作为密码注册一个新买家。
3. 创建一个唯一的卖家 ID（user_id）和商店 ID（store_id）。
4. 使用卖家 ID 作为密码注册一个新卖家。
5. 创建一个商店，并将其与卖家关联。
6. 初始化一个关键字（keyword）和 RequestSearch 对象（rs）。
7. 从图书数据库中获取一本图书信息。
**测试用例：**

1. test_all_field_search(): 测试搜索所有字段的情况。 调用 buyer.search()方法进行搜索操作。 断言操作返回码为 200，表示搜索成功。
2. test_pagination(): 测试分页搜索的情况。 调用 buyer.search()方法进行分页搜索操作。 断言操作返回码为 200，表示搜索成功。
3. test_search_title(): 测试按标题搜索的情况。 创建一个唯一的标题，并将图书的标题修改为该标题。 调用 seller.add_book()方法将图书添加到商店中。 调用 rs.request_search_title()方法进行标题搜索操作。 断言操作返回码为 200，表示搜索成功。 再次调用 rs.request_search_title()方法尝试搜索不存在的标题。 断言操作返回码为 501，表示搜索失败。
4. test_search_title_in_store(): 测试在商店中按标题搜索的情况。 创建一个唯一的标题，并将图书的标题修改为该标题。 调用 seller.add_book()方法将图书添加到商店中。 调用 rs.request_search_title_in_store()方法进行商店中的标题搜索操作。 断言操作返回码为 200，表示搜索成功。 再次调用 rs.request_search_title_in_store()方法尝试搜索不存在的标题。 断言操作返回码为 501，表示搜索失败。
5. test_search_tag(): 测试按标签搜索的情况。 创建一个唯一的标签，并将图书的标签修改为该标签。 调用 seller.add_book()方法将图书添加到商店中。 调用 rs.request_search_tag()方法进行标签搜索操作。 断言操作返回码为 200，表示搜索成功。 再次调用 rs.request_search_tag()方法尝试搜索不存在的标签。 断言操作返回码为 501，表示搜索失败。
6. test_search_tag_in_store(): 测试在商店中按标签搜索的情况。 创建一个唯一的标签，并将图书的标签修改为该标签。 调用 seller.add_book()方法将图书添加到商店中。 调用 rs.request_search_tag_in_store()方法进行商店中的标签搜索操作。 断言操作返回码为 200，表示搜索成功。 再次调用 rs.request_search_tag_in_store()方法尝试搜索不存在的标签。 断言操作返回码为 501，表示搜索失败。
7. test_search_author(): 测试按作者搜索的情况。 创建一个唯一的作者，并将图书的作者修改为该作者。 调用 seller.add_book()方法将图书添加到商店中。 调用 rs.request_search_author()方法进行作者搜索操作。 断言操作返回码为 200，表示搜索成功。 再次调用 rs.request_search_author()方法尝试搜索不存在的作者。 断言操作返回码为 501，表示搜索失败。
8. test_search_author_in_store(): 测试在商店中按作者搜索的情况。 创建一个唯一的作者，并将图书的作者修改为该作者。 调用 seller.add_book()方法将图书添加到商店中。 调用 rs.request_search_author_in_store()方法进行商店中的作者搜索操作。 断言操作返回码为 200，表示搜索成功。 再次调用 rs.request_search_author_in_store()方法尝试搜索不存在的作者。 断言操作返回码为 501，表示搜索失败。
9. test_search_content(): 测试按内容搜索的情况。 创建一个唯一的关键字，并将图书的简介中包含该关键字。 调用 seller.add_book()方法将图书添加到商店中。 调用 rs.request_search_content()方法进行内容搜索操作。 断言操作返回码为 200，表示搜索成功。 再次调用 rs.request_search_content()方法尝试搜索不存在的关键字。 断言操作返回码为 501，表示搜索失败。
10. test_search_content_in_store(): 测试在商店中按内容搜索的情况。 创建一个唯一的关键字，并将图书的简介中包含该关键字。 调用 seller.add_book()方法将图书添加到商店中。 调用 rs.request_search_content_in_store()方法进行商店中的内容搜索操作。 断言操作返回码为 200，表示搜索成功。 再次调用 rs.request_search_content_in_store()方法尝试搜索不存在的关键字。 断言操作返回码为 501，表示搜索失败。
11. test_search_price_range(): 测试按价格范围搜索的情况。 创建一个唯一的价格，并将图书的价格修改为该价格。 调用 seller.add_book()方法将图书添加到商店中。 调用 rs.request_search_price_range()方法进行价格范围搜索操作。 断言操作返回码为 200，表示搜索成功。 再次调用 rs.request_search_price_range()方法尝试搜索不存在的价格范围。 断言操作返回码为 501，表示搜索失败。
12. test_search_price_range_in_store(): 测试在商店中按价格范围搜索的情况。 创建一个唯一的价格，并将图书的价格修改为该价格。 调用 seller.add_book()方法将图书添加到商店中。 调用 rs.request_search_price_range_in_store()方法进行商店中的价格范围搜索操作。 断言操作返回码为 200，表示搜索成功。 再次调用 rs.request_search_price_range_in_store()方法尝试搜索不存在的价格范围。 断言操作返回码为 501，表示搜索失败。
13. test_search_rating(): 测试按评分搜索的情况。 创建一个唯一的评分，并将图书的评分修改为该评分。 调用 seller.add_book()方法将图书添加到商店中。 调用 rs.request_search_rating()方法进行评分搜索操作。 断言操作返回码为 200，表示搜索成功。 再次调用 rs.request_search_rating()方法尝试搜索不存在的评分。 断言操作返回码为 501，表示搜索失败。
14. test_search_rating_in_store(): 测试在商店中按评分搜索的情况。 创建一个唯一的评分，并将图书的评分修改为该评分。 调用 seller.add_book()方法将图书添加到商店中。 调用 rs.request_search_rating_in_store()方法进行商店中的评分搜索操作。 断言操作返回码为 200，表示搜索成功。 再次调用 rs.request_search_rating_in_store()方法尝试搜索不存在的评分。 断言操作返回码为 501，表示搜索失败。
## 7.15 test_send.py

在测试之前，会自动执行一些初始化操作：

1. 创建一个唯一的卖家 ID（seller_id）、商店 ID（store_id）和买家 ID（buyer_id）。
2. 使用买家 ID 作为密码注册一个新买家。
3. 生成图书数据，并将其与卖家和商店关联。
4. 生成购买图书的订单，包括购买图书的信息和总价格。
5. 为买家账户充值足够的金额以支付订单。
6. 创建订单并进行支付。
**测试用例：**

1. `test_ok()` : 测试成功发送图书的情况。 调用 `send_books()`方法发送图书。 断言操作返回码为 200，表示发送成功。
2. `test_order_error()`: 测试使用不存在的订单 ID 发送图书的情况。 使用不存在的订单 ID 调用 `send_books()`方法尝试发送图书。 断言操作返回码不为 200，表示发送失败。
3. `test_authorization_error()`: 测试使用不存在的卖家 ID 发送图书的情况。 使用不存在的卖家 ID 调用 `send_books()`方法尝试发送图书。 断言操作返回码不为 200，表示发送失败。
4. test_books_repeat_send(): 测试重复发送图书的情况。 先发送图书到订单。 再次使用相同的卖家 ID 和订单 ID 调用 `send_books()`方法尝试发送图书。 断言操作返回码不为 200，表示发送失败。

---
# 8. 测试结果


---
# 9. 项目分工和后记
## 9.1 协作方式

在本次实验过程中，我们使用了 Git 进行了版本管理，即本仓库内容。

需要注意的是，由于我们的**主要开发工作是在线下环境完成**，且对于 git 版本管理系统的工作方式仍然不是十分熟悉，因此在代码的提交时间和实时同步更新方面存在一定的滞后性，导致 **GitHub 上的版本更新记录可能并不完全反映每一次正确的改动**，降低了其作为实时参考依据的价值。但即便由于线下工作的特性，部分更新可能当场解决了而未能立即同步至线上，但我们依然重视利用 Git 工具来记录每个阶段的代码变更，以便于后期整合与追溯。

纵使我们的版本记录不一定足够及时，不一定具有参考性，但在实验报告的编写过程中，我们尽量详尽地记录还原了各个关键步骤与代码迭代情况，确保实验过程的透明度和完整性，这也一定程度弥补了这一部分。

## 9.2 后记

我们小组在完成实验过程中，采用了 MongoDB 数据库，并将数据从 SQLite 转移到了 MongoDB，以提高数据读写的效率。以下是我们在实验中的一些收获和总结：

1. **数据库迁移与转换**：我们学会了如何迁移和转换不同类型的数据库。从 SQLite 到 MongoDB 的迁移涉及到数据结构的转换和数据的导入，我们通过编写 Python 脚本完成了这个任务，并确保数据的完整性和一致性。
2. **代码测试与覆盖率**：根据实验要求，我们运用已有的测试用例并尝试编写了自己的定制化测试用例，并使用测试工具计算了测试覆盖率。通过测试，我们能够及时发现和修复潜在的问题，确保项目的稳定性和可靠性。
3. **版本管理与团队协作**：我们采用了 Git 等版本管理工具来管理项目代码，实现了团队成员之间的协作和代码的版本控制。这让我们能够更好地管理和维护项目，提高了工作效率和代码质量。
总的来说，这次实验让我们学到了很多关于 Web 开发、数据库管理和团队协作的知识和技能，对我们的专业能力和团队合作能力都有很大的提升。

